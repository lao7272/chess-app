{"ast":null,"code":"import Piece from \"../Piece\";\nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class Rook extends Piece {\n  constructor(position, team, hasMoved) {\n    let possibleMoves = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    super(position, team, \"rook\", possibleMoves);\n    this.hasMoved = hasMoved;\n  }\n  getPossibleMoves(pieces) {\n    const x = this.position.x;\n    const y = this.position.y;\n    // TOP\n    for (let i = 1; i < 8; i++) {\n      if (y + i > 7) break;\n      let passedTile = new Position(x, y + i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // BOTTOM\n    for (let i = 1; i < 8; i++) {\n      if (y - i < 0) break;\n      let passedTile = new Position(x, y - i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // RIGHT\n    for (let i = 1; i < 8; i++) {\n      if (x + i > 7) break;\n      let passedTile = new Position(x + i, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // LEFT\n    for (let i = 1; i < 8; i++) {\n      if (x - i < 0) break;\n      let passedTile = new Position(x - i, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    return this.possibleMoves;\n  }\n  clone() {\n    return new Rook(this.position.clone(), this.team, this.hasMoved, this.possibleMoves.map(move => move.clone()));\n  }\n}","map":{"version":3,"names":["Piece","Position","Movement","movement","Rook","constructor","position","team","hasMoved","possibleMoves","arguments","length","undefined","getPossibleMoves","pieces","x","y","i","passedTile","tileIsEmptyOrCaptured","push","tileIsOccupied","clone","map","move"],"sources":["/Users/lao/Desktop/chess-app/client/src/models/pieces/Rook.js"],"sourcesContent":["import Piece from \"../Piece\";\nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class Rook extends Piece {\n    constructor (position, team, hasMoved, possibleMoves = []) {\n        super(position, team, \"rook\", possibleMoves);\n        this.hasMoved = hasMoved;\n    }\n\n    getPossibleMoves(pieces) {\n        const x = this.position.x;\n        const y = this.position.y;\n        // TOP\n        for (let i = 1; i < 8; i++) {\n            if(y + i > 7) break;\n            let passedTile = new Position(x, y + i);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n                this.possibleMoves.push(passedTile)\n            };\n            if (movement.tileIsOccupied(passedTile, pieces)) break;\n        }\n        // BOTTOM\n        for (let i = 1; i < 8; i++) {\n            if(y - i < 0) break;\n            let passedTile = new Position(x, y - i);\n            \n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n                this.possibleMoves.push(passedTile)\n            };\n            if (movement.tileIsOccupied(passedTile, pieces)) break;\n        }\n        // RIGHT\n        for (let i = 1; i < 8; i++) {\n            if(x + i > 7) break;\n            let passedTile = new Position(x + i, y);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n                this.possibleMoves.push(passedTile)\n            };\n            if (movement.tileIsOccupied(passedTile, pieces)) break;\n        }\n        // LEFT\n        for (let i = 1; i < 8; i++) {\n            if(x - i < 0) break;\n            let passedTile = new Position(x - i, y);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n                this.possibleMoves.push(passedTile)\n            };\n            if (movement.tileIsOccupied(passedTile, pieces)) break;\n        }\n        return this.possibleMoves;\n    }\n    clone(){\n        return new Rook(this.position.clone(), this.team, this.hasMoved, this.possibleMoves.map(move => move.clone()));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}