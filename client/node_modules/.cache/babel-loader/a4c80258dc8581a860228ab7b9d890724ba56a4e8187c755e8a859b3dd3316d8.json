{"ast":null,"code":"export default class Chessboard {\n  constructor(pieces) {\n    let totalTurns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let moveList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    this.pieces = pieces;\n    this.totalTurns = totalTurns;\n    this.moveList = moveList;\n    this.winningTeam = null;\n    this.draw = false;\n  }\n  get getCurrentTeam() {\n    return this.totalTurns % 2 === 0 ? \"black\" : \"white\";\n  }\n  getPossibleMoves() {\n    if (this.pieces.length === 2) {\n      this.draw = true;\n      return;\n    }\n    for (const piece of this.pieces) {\n      piece.possibleMoves = piece.getPossibleMoves(this.pieces);\n    }\n    const king = this.pieces.find(p => p.isKing && p.team === this.getCurrentTeam);\n    // Castling\n    king.possibleMoves = [...king.possibleMoves, ...king.castling(this.pieces)];\n    // Checks the current team valid moves\n    this.getTeamDangerousMoves();\n    for (const piece of this.pieces) {\n      if (piece.team !== this.getCurrentTeam) {\n        piece.possibleMoves = [];\n      }\n    }\n    const getTeamPieces = this.pieces.filter(p => p.team === this.getCurrentTeam);\n    if (getTeamPieces.some(p => p.possibleMoves.length > 0)) return;\n    if (this.isKingChecked(king)) {\n      this.winningTeam = this.getCurrentTeam === 'white' ? \"black\" : \"white\";\n    } else {\n      this.draw = true;\n    }\n  }\n  getTeamDangerousMoves() {\n    for (const piece of this.pieces.filter(p => p.team === this.getCurrentTeam)) {\n      for (const move of piece.possibleMoves) {\n        // Simulate the chessboard \n        const clonedBoard = this.clone();\n        clonedBoard.pieces = clonedBoard.pieces.filter(p => !p.samePosition(move));\n        const clonedPiece = clonedBoard.pieces.find(p => p.samePosition(piece.position));\n        clonedPiece.position = move.clone();\n        const clonedKing = clonedBoard.pieces.find(p => p.isKing && p.team === clonedBoard.getCurrentTeam);\n        const filterTeamPieces = clonedBoard.pieces.filter(p => p.team !== clonedBoard.getCurrentTeam);\n        for (const enemy of filterTeamPieces) {\n          enemy.possibleMoves = [];\n          const newEnemy = clonedBoard.pieces.find(p => p.samePosition(enemy.position) && p.team !== clonedBoard.getCurrentTeam);\n          enemy.possibleMoves = newEnemy.getPossibleMoves(clonedBoard.pieces);\n          if (enemy.isPawn) {\n            const isDangerousMove = enemy.possibleMoves.some(m => m.x !== enemy.position.x && m.samePosition(clonedKing.position));\n            if (isDangerousMove) piece.possibleMoves = piece.possibleMoves.filter(m => !m.samePosition(move));\n          } else {\n            if (enemy.possibleMoves.some(m => m.samePosition(clonedKing.position))) {\n              piece.possibleMoves = piece.possibleMoves.filter(m => !m.samePosition(move));\n            }\n            ;\n          }\n        }\n      }\n    }\n  }\n  isKingChecked(king) {\n    for (const enemy of this.pieces.filter(p => p.team !== this.getCurrentTeam)) {\n      const isChecked = enemy.getPossibleMoves(this.pieces).some(m => m.samePosition(king.position));\n      if (isChecked) return true;\n    }\n    return false;\n  }\n  playMove(currentPiece, desiredPosition, validMove) {\n    const {\n      x,\n      y\n    } = desiredPosition;\n    const pawnDirection = currentPiece.team === 'white' ? 1 : -1;\n    let isEnPassant = false;\n    if (currentPiece.type === \"pawn\") {\n      isEnPassant = currentPiece.isEnPassant(desiredPosition, this.pieces);\n    }\n    if (currentPiece.isKing && (currentPiece.position.x - desiredPosition.x === 2 || currentPiece.position.x - desiredPosition.x === -2)) {\n      const xPosition = currentPiece.position.x - desiredPosition.x === 2 ? 0 : 7;\n      const yPosition = currentPiece.team === \"white\" ? 0 : 7;\n\n      // Check castling\n      const rook = this.pieces.find(p => p.isRook && p.position.x === xPosition && p.position.y === yPosition);\n      if (rook) {\n        this.pieces = this.pieces.map(piece => {\n          if (piece.samePosition(currentPiece.position)) {\n            piece.position.x = desiredPosition.x;\n          }\n          if (piece.samePosition(rook.position)) {\n            const direction = xPosition === 0 ? -1 : 1;\n            piece.position.x = desiredPosition.x - direction;\n          }\n          return piece;\n        });\n      }\n      this.getPossibleMoves();\n    }\n    // Check enPassant\n    else if (isEnPassant) {\n      this.pieces = this.pieces.reduce((result, piece) => {\n        if (piece.samePosition(currentPiece.position)) {\n          if (piece.isPawn) piece.enPassant = false;\n          piece.position.x = x;\n          piece.position.y = y;\n          piece.hasMoved = true;\n          result.push(piece);\n        } else if (!piece.samePosition({\n          x,\n          y: y - pawnDirection\n        })) {\n          if (piece.isPawn) piece.enPassant = false;\n          result.push(piece);\n        }\n        return result;\n      }, []);\n      this.getPossibleMoves();\n    }\n    // Checks valid move\n    else if (validMove) {\n      // UPDATES THE PIECE POSITION AND CAPTURES\n      this.pieces = this.pieces.reduce((result, piece) => {\n        if (piece.samePosition(currentPiece.position)) {\n          // Special pawn move\n          if (piece.isPawn) piece.enPassant = Math.abs(currentPiece.position.y - y) === 2;\n          if (piece.isKing || piece.isRook) {\n            piece.hasMoved = true;\n          }\n          piece.position.x = x;\n          piece.position.y = y;\n          result.push(piece);\n        } else if (!piece.samePosition({\n          x,\n          y\n        })) {\n          if (piece.isPawn) piece.enPassant = false;\n          result.push(piece);\n        }\n        return result;\n      }, []);\n      this.getPossibleMoves();\n    } else {\n      return false;\n    }\n    return true;\n  }\n  clone() {\n    return new Chessboard(this.pieces.map(piece => piece.clone()), this.totalTurns, this.moveList);\n  }\n}","map":{"version":3,"names":["Chessboard","constructor","pieces","totalTurns","arguments","length","undefined","moveList","winningTeam","draw","getCurrentTeam","getPossibleMoves","piece","possibleMoves","king","find","p","isKing","team","castling","getTeamDangerousMoves","getTeamPieces","filter","some","isKingChecked","move","clonedBoard","clone","samePosition","clonedPiece","position","clonedKing","filterTeamPieces","enemy","newEnemy","isPawn","isDangerousMove","m","x","isChecked","playMove","currentPiece","desiredPosition","validMove","y","pawnDirection","isEnPassant","type","xPosition","yPosition","rook","isRook","map","direction","reduce","result","enPassant","hasMoved","push","Math","abs"],"sources":["/Users/lao/Desktop/chess-app/src/models/Chessboard.js"],"sourcesContent":["export default class Chessboard {\n    constructor(pieces, totalTurns = 0, moveList = []) {\n        this.pieces = pieces;\n        this.totalTurns = totalTurns;\n        this.moveList = moveList;\n        this.winningTeam = null;\n        this.draw = false;\n    }\n    get getCurrentTeam() {\n        return this.totalTurns % 2 === 0 ? \"black\" : \"white\";\n    }\n    getPossibleMoves() {\n        if (this.pieces.length === 2) {\n            this.draw = true;\n            return;\n        }\n        for (const piece of this.pieces) {\n            piece.possibleMoves = piece.getPossibleMoves(this.pieces);\n        }\n        const king = this.pieces.find(p => p.isKing && p.team === this.getCurrentTeam);\n        // Castling\n        king.possibleMoves = [...king.possibleMoves, ...king.castling(this.pieces)];\n        // Checks the current team valid moves\n        this.getTeamDangerousMoves();\n\n        for (const piece of this.pieces) {\n            if (piece.team !== this.getCurrentTeam) {\n                piece.possibleMoves = [];\n            }\n        }\n        const getTeamPieces = this.pieces.filter(p => p.team === this.getCurrentTeam);\n        if (getTeamPieces.some(p => p.possibleMoves.length > 0)) return;\n        if (this.isKingChecked(king)) {\n            this.winningTeam = this.getCurrentTeam === 'white' ? \"black\" : \"white\";\n        } else {\n            this.draw = true;\n        }\n    }\n\n    getTeamDangerousMoves() {\n\n        for (const piece of this.pieces.filter(p => p.team === this.getCurrentTeam)) {\n            for (const move of piece.possibleMoves) {\n                // Simulate the chessboard \n                const clonedBoard = this.clone();\n                clonedBoard.pieces = clonedBoard.pieces.filter(p => !p.samePosition(move));\n                const clonedPiece = clonedBoard.pieces.find(p => p.samePosition(piece.position));\n                clonedPiece.position = move.clone();\n                const clonedKing = clonedBoard.pieces.find(p => p.isKing && p.team === clonedBoard.getCurrentTeam);\n                const filterTeamPieces = clonedBoard.pieces.filter(p => p.team !== clonedBoard.getCurrentTeam);\n\n                for (const enemy of filterTeamPieces) {\n                    enemy.possibleMoves = [];\n                    const newEnemy = clonedBoard.pieces.find(p => p.samePosition(enemy.position) && p.team !== clonedBoard.getCurrentTeam);\n                    enemy.possibleMoves = newEnemy.getPossibleMoves(clonedBoard.pieces);\n                    if (enemy.isPawn) {\n                        const isDangerousMove = enemy.possibleMoves.some(m => m.x !== enemy.position.x && m.samePosition(clonedKing.position));\n                        if (isDangerousMove) piece.possibleMoves = piece.possibleMoves.filter(m => !m.samePosition(move));\n                    } else {\n                        if (enemy.possibleMoves.some(m => m.samePosition(clonedKing.position))) {\n                            piece.possibleMoves = piece.possibleMoves.filter(m => !m.samePosition(move));\n                        };\n                    }\n                }\n            }\n        }\n    }\n    isKingChecked(king) {\n        for (const enemy of this.pieces.filter(p => p.team !== this.getCurrentTeam)) {\n            const isChecked = enemy.getPossibleMoves(this.pieces).some(m => m.samePosition(king.position));\n            if (isChecked) return true;\n        }\n        return false;\n    }\n    playMove(currentPiece, desiredPosition, validMove) {\n        const { x, y } = desiredPosition;\n\n        const pawnDirection = currentPiece.team === 'white' ? 1 : -1;\n        let isEnPassant = false;\n        if (currentPiece.type === \"pawn\") {\n            isEnPassant = currentPiece.isEnPassant(desiredPosition, this.pieces);\n        }\n\n        if (currentPiece.isKing && (currentPiece.position.x - desiredPosition.x === 2 || currentPiece.position.x - desiredPosition.x === -2)) {\n            const xPosition = currentPiece.position.x - desiredPosition.x === 2 ? 0 : 7;\n            const yPosition = currentPiece.team === \"white\" ? 0 : 7;\n\n            // Check castling\n            const rook = this.pieces.find(p => p.isRook && p.position.x === xPosition && p.position.y === yPosition);\n            if (rook) {\n                this.pieces = this.pieces.map(piece => {\n                    if (piece.samePosition(currentPiece.position)) {\n                        piece.position.x = desiredPosition.x;\n                                    } if (piece.samePosition(rook.position)) {\n                        const direction = xPosition === 0 ? -1 : 1;\n                        piece.position.x = desiredPosition.x - direction;\n                    }\n                    return piece;\n                })\n            }\n            this.getPossibleMoves();\n        }\n        // Check enPassant\n        else if (isEnPassant) {\n            this.pieces = this.pieces.reduce((result, piece) => {\n                if (piece.samePosition(currentPiece.position)) {\n                    if (piece.isPawn) piece.enPassant = false;\n                    piece.position.x = x;\n                    piece.position.y = y;\n                    piece.hasMoved = true;\n                    result.push(piece);\n\n            \n                } else if (!piece.samePosition({ x, y: y - pawnDirection })) {\n                    if (piece.isPawn) piece.enPassant = false;\n                    result.push(piece);\n                }\n                return result\n            }, []);\n            this.getPossibleMoves();\n        }\n        // Checks valid move\n        else if (validMove) {\n            // UPDATES THE PIECE POSITION AND CAPTURES\n            this.pieces = this.pieces.reduce((result, piece) => {\n                if (piece.samePosition(currentPiece.position)) {\n                    // Special pawn move\n                    if (piece.isPawn) piece.enPassant = Math.abs(currentPiece.position.y - y) === 2;\n                    if (piece.isKing || piece.isRook) {\n                        piece.hasMoved = true;\n                    }\n                    piece.position.x = x;\n                    piece.position.y = y;\n                    result.push(piece);\n\n            \n                } else if (!piece.samePosition({ x, y })) {\n                    if (piece.isPawn) piece.enPassant = false;\n                    result.push(piece);\n                }\n                return result\n            }, []);\n            this.getPossibleMoves();\n        } else {\n            return false;\n        }\n        return true\n    }\n\n    clone() {\n        return new Chessboard(this.pieces.map(piece => piece.clone()), this.totalTurns, this.moveList);\n    }\n} "],"mappings":"AAAA,eAAe,MAAMA,UAAU,CAAC;EAC5BC,WAAWA,CAACC,MAAM,EAAiC;IAAA,IAA/BC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,IAAEG,QAAQ,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IAC7C,IAAI,CAACF,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACI,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,IAAI,GAAG,KAAK;EACrB;EACA,IAAIC,cAAcA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACP,UAAU,GAAG,CAAC,KAAK,CAAC,GAAG,OAAO,GAAG,OAAO;EACxD;EACAQ,gBAAgBA,CAAA,EAAG;IACf,IAAI,IAAI,CAACT,MAAM,CAACG,MAAM,KAAK,CAAC,EAAE;MAC1B,IAAI,CAACI,IAAI,GAAG,IAAI;MAChB;IACJ;IACA,KAAK,MAAMG,KAAK,IAAI,IAAI,CAACV,MAAM,EAAE;MAC7BU,KAAK,CAACC,aAAa,GAAGD,KAAK,CAACD,gBAAgB,CAAC,IAAI,CAACT,MAAM,CAAC;IAC7D;IACA,MAAMY,IAAI,GAAG,IAAI,CAACZ,MAAM,CAACa,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,IAAID,CAAC,CAACE,IAAI,KAAK,IAAI,CAACR,cAAc,CAAC;IAC9E;IACAI,IAAI,CAACD,aAAa,GAAG,CAAC,GAAGC,IAAI,CAACD,aAAa,EAAE,GAAGC,IAAI,CAACK,QAAQ,CAAC,IAAI,CAACjB,MAAM,CAAC,CAAC;IAC3E;IACA,IAAI,CAACkB,qBAAqB,EAAE;IAE5B,KAAK,MAAMR,KAAK,IAAI,IAAI,CAACV,MAAM,EAAE;MAC7B,IAAIU,KAAK,CAACM,IAAI,KAAK,IAAI,CAACR,cAAc,EAAE;QACpCE,KAAK,CAACC,aAAa,GAAG,EAAE;MAC5B;IACJ;IACA,MAAMQ,aAAa,GAAG,IAAI,CAACnB,MAAM,CAACoB,MAAM,CAACN,CAAC,IAAIA,CAAC,CAACE,IAAI,KAAK,IAAI,CAACR,cAAc,CAAC;IAC7E,IAAIW,aAAa,CAACE,IAAI,CAACP,CAAC,IAAIA,CAAC,CAACH,aAAa,CAACR,MAAM,GAAG,CAAC,CAAC,EAAE;IACzD,IAAI,IAAI,CAACmB,aAAa,CAACV,IAAI,CAAC,EAAE;MAC1B,IAAI,CAACN,WAAW,GAAG,IAAI,CAACE,cAAc,KAAK,OAAO,GAAG,OAAO,GAAG,OAAO;IAC1E,CAAC,MAAM;MACH,IAAI,CAACD,IAAI,GAAG,IAAI;IACpB;EACJ;EAEAW,qBAAqBA,CAAA,EAAG;IAEpB,KAAK,MAAMR,KAAK,IAAI,IAAI,CAACV,MAAM,CAACoB,MAAM,CAACN,CAAC,IAAIA,CAAC,CAACE,IAAI,KAAK,IAAI,CAACR,cAAc,CAAC,EAAE;MACzE,KAAK,MAAMe,IAAI,IAAIb,KAAK,CAACC,aAAa,EAAE;QACpC;QACA,MAAMa,WAAW,GAAG,IAAI,CAACC,KAAK,EAAE;QAChCD,WAAW,CAACxB,MAAM,GAAGwB,WAAW,CAACxB,MAAM,CAACoB,MAAM,CAACN,CAAC,IAAI,CAACA,CAAC,CAACY,YAAY,CAACH,IAAI,CAAC,CAAC;QAC1E,MAAMI,WAAW,GAAGH,WAAW,CAACxB,MAAM,CAACa,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACY,YAAY,CAAChB,KAAK,CAACkB,QAAQ,CAAC,CAAC;QAChFD,WAAW,CAACC,QAAQ,GAAGL,IAAI,CAACE,KAAK,EAAE;QACnC,MAAMI,UAAU,GAAGL,WAAW,CAACxB,MAAM,CAACa,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,IAAID,CAAC,CAACE,IAAI,KAAKQ,WAAW,CAAChB,cAAc,CAAC;QAClG,MAAMsB,gBAAgB,GAAGN,WAAW,CAACxB,MAAM,CAACoB,MAAM,CAACN,CAAC,IAAIA,CAAC,CAACE,IAAI,KAAKQ,WAAW,CAAChB,cAAc,CAAC;QAE9F,KAAK,MAAMuB,KAAK,IAAID,gBAAgB,EAAE;UAClCC,KAAK,CAACpB,aAAa,GAAG,EAAE;UACxB,MAAMqB,QAAQ,GAAGR,WAAW,CAACxB,MAAM,CAACa,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACY,YAAY,CAACK,KAAK,CAACH,QAAQ,CAAC,IAAId,CAAC,CAACE,IAAI,KAAKQ,WAAW,CAAChB,cAAc,CAAC;UACtHuB,KAAK,CAACpB,aAAa,GAAGqB,QAAQ,CAACvB,gBAAgB,CAACe,WAAW,CAACxB,MAAM,CAAC;UACnE,IAAI+B,KAAK,CAACE,MAAM,EAAE;YACd,MAAMC,eAAe,GAAGH,KAAK,CAACpB,aAAa,CAACU,IAAI,CAACc,CAAC,IAAIA,CAAC,CAACC,CAAC,KAAKL,KAAK,CAACH,QAAQ,CAACQ,CAAC,IAAID,CAAC,CAACT,YAAY,CAACG,UAAU,CAACD,QAAQ,CAAC,CAAC;YACtH,IAAIM,eAAe,EAAExB,KAAK,CAACC,aAAa,GAAGD,KAAK,CAACC,aAAa,CAACS,MAAM,CAACe,CAAC,IAAI,CAACA,CAAC,CAACT,YAAY,CAACH,IAAI,CAAC,CAAC;UACrG,CAAC,MAAM;YACH,IAAIQ,KAAK,CAACpB,aAAa,CAACU,IAAI,CAACc,CAAC,IAAIA,CAAC,CAACT,YAAY,CAACG,UAAU,CAACD,QAAQ,CAAC,CAAC,EAAE;cACpElB,KAAK,CAACC,aAAa,GAAGD,KAAK,CAACC,aAAa,CAACS,MAAM,CAACe,CAAC,IAAI,CAACA,CAAC,CAACT,YAAY,CAACH,IAAI,CAAC,CAAC;YAChF;YAAC;UACL;QACJ;MACJ;IACJ;EACJ;EACAD,aAAaA,CAACV,IAAI,EAAE;IAChB,KAAK,MAAMmB,KAAK,IAAI,IAAI,CAAC/B,MAAM,CAACoB,MAAM,CAACN,CAAC,IAAIA,CAAC,CAACE,IAAI,KAAK,IAAI,CAACR,cAAc,CAAC,EAAE;MACzE,MAAM6B,SAAS,GAAGN,KAAK,CAACtB,gBAAgB,CAAC,IAAI,CAACT,MAAM,CAAC,CAACqB,IAAI,CAACc,CAAC,IAAIA,CAAC,CAACT,YAAY,CAACd,IAAI,CAACgB,QAAQ,CAAC,CAAC;MAC9F,IAAIS,SAAS,EAAE,OAAO,IAAI;IAC9B;IACA,OAAO,KAAK;EAChB;EACAC,QAAQA,CAACC,YAAY,EAAEC,eAAe,EAAEC,SAAS,EAAE;IAC/C,MAAM;MAAEL,CAAC;MAAEM;IAAE,CAAC,GAAGF,eAAe;IAEhC,MAAMG,aAAa,GAAGJ,YAAY,CAACvB,IAAI,KAAK,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;IAC5D,IAAI4B,WAAW,GAAG,KAAK;IACvB,IAAIL,YAAY,CAACM,IAAI,KAAK,MAAM,EAAE;MAC9BD,WAAW,GAAGL,YAAY,CAACK,WAAW,CAACJ,eAAe,EAAE,IAAI,CAACxC,MAAM,CAAC;IACxE;IAEA,IAAIuC,YAAY,CAACxB,MAAM,KAAKwB,YAAY,CAACX,QAAQ,CAACQ,CAAC,GAAGI,eAAe,CAACJ,CAAC,KAAK,CAAC,IAAIG,YAAY,CAACX,QAAQ,CAACQ,CAAC,GAAGI,eAAe,CAACJ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;MAClI,MAAMU,SAAS,GAAGP,YAAY,CAACX,QAAQ,CAACQ,CAAC,GAAGI,eAAe,CAACJ,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;MAC3E,MAAMW,SAAS,GAAGR,YAAY,CAACvB,IAAI,KAAK,OAAO,GAAG,CAAC,GAAG,CAAC;;MAEvD;MACA,MAAMgC,IAAI,GAAG,IAAI,CAAChD,MAAM,CAACa,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACmC,MAAM,IAAInC,CAAC,CAACc,QAAQ,CAACQ,CAAC,KAAKU,SAAS,IAAIhC,CAAC,CAACc,QAAQ,CAACc,CAAC,KAAKK,SAAS,CAAC;MACxG,IAAIC,IAAI,EAAE;QACN,IAAI,CAAChD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACkD,GAAG,CAACxC,KAAK,IAAI;UACnC,IAAIA,KAAK,CAACgB,YAAY,CAACa,YAAY,CAACX,QAAQ,CAAC,EAAE;YAC3ClB,KAAK,CAACkB,QAAQ,CAACQ,CAAC,GAAGI,eAAe,CAACJ,CAAC;UACxB;UAAE,IAAI1B,KAAK,CAACgB,YAAY,CAACsB,IAAI,CAACpB,QAAQ,CAAC,EAAE;YACrD,MAAMuB,SAAS,GAAGL,SAAS,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;YAC1CpC,KAAK,CAACkB,QAAQ,CAACQ,CAAC,GAAGI,eAAe,CAACJ,CAAC,GAAGe,SAAS;UACpD;UACA,OAAOzC,KAAK;QAChB,CAAC,CAAC;MACN;MACA,IAAI,CAACD,gBAAgB,EAAE;IAC3B;IACA;IAAA,KACK,IAAImC,WAAW,EAAE;MAClB,IAAI,CAAC5C,MAAM,GAAG,IAAI,CAACA,MAAM,CAACoD,MAAM,CAAC,CAACC,MAAM,EAAE3C,KAAK,KAAK;QAChD,IAAIA,KAAK,CAACgB,YAAY,CAACa,YAAY,CAACX,QAAQ,CAAC,EAAE;UAC3C,IAAIlB,KAAK,CAACuB,MAAM,EAAEvB,KAAK,CAAC4C,SAAS,GAAG,KAAK;UACzC5C,KAAK,CAACkB,QAAQ,CAACQ,CAAC,GAAGA,CAAC;UACpB1B,KAAK,CAACkB,QAAQ,CAACc,CAAC,GAAGA,CAAC;UACpBhC,KAAK,CAAC6C,QAAQ,GAAG,IAAI;UACrBF,MAAM,CAACG,IAAI,CAAC9C,KAAK,CAAC;QAGtB,CAAC,MAAM,IAAI,CAACA,KAAK,CAACgB,YAAY,CAAC;UAAEU,CAAC;UAAEM,CAAC,EAAEA,CAAC,GAAGC;QAAc,CAAC,CAAC,EAAE;UACzD,IAAIjC,KAAK,CAACuB,MAAM,EAAEvB,KAAK,CAAC4C,SAAS,GAAG,KAAK;UACzCD,MAAM,CAACG,IAAI,CAAC9C,KAAK,CAAC;QACtB;QACA,OAAO2C,MAAM;MACjB,CAAC,EAAE,EAAE,CAAC;MACN,IAAI,CAAC5C,gBAAgB,EAAE;IAC3B;IACA;IAAA,KACK,IAAIgC,SAAS,EAAE;MAChB;MACA,IAAI,CAACzC,MAAM,GAAG,IAAI,CAACA,MAAM,CAACoD,MAAM,CAAC,CAACC,MAAM,EAAE3C,KAAK,KAAK;QAChD,IAAIA,KAAK,CAACgB,YAAY,CAACa,YAAY,CAACX,QAAQ,CAAC,EAAE;UAC3C;UACA,IAAIlB,KAAK,CAACuB,MAAM,EAAEvB,KAAK,CAAC4C,SAAS,GAAGG,IAAI,CAACC,GAAG,CAACnB,YAAY,CAACX,QAAQ,CAACc,CAAC,GAAGA,CAAC,CAAC,KAAK,CAAC;UAC/E,IAAIhC,KAAK,CAACK,MAAM,IAAIL,KAAK,CAACuC,MAAM,EAAE;YAC9BvC,KAAK,CAAC6C,QAAQ,GAAG,IAAI;UACzB;UACA7C,KAAK,CAACkB,QAAQ,CAACQ,CAAC,GAAGA,CAAC;UACpB1B,KAAK,CAACkB,QAAQ,CAACc,CAAC,GAAGA,CAAC;UACpBW,MAAM,CAACG,IAAI,CAAC9C,KAAK,CAAC;QAGtB,CAAC,MAAM,IAAI,CAACA,KAAK,CAACgB,YAAY,CAAC;UAAEU,CAAC;UAAEM;QAAE,CAAC,CAAC,EAAE;UACtC,IAAIhC,KAAK,CAACuB,MAAM,EAAEvB,KAAK,CAAC4C,SAAS,GAAG,KAAK;UACzCD,MAAM,CAACG,IAAI,CAAC9C,KAAK,CAAC;QACtB;QACA,OAAO2C,MAAM;MACjB,CAAC,EAAE,EAAE,CAAC;MACN,IAAI,CAAC5C,gBAAgB,EAAE;IAC3B,CAAC,MAAM;MACH,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EAEAgB,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAI3B,UAAU,CAAC,IAAI,CAACE,MAAM,CAACkD,GAAG,CAACxC,KAAK,IAAIA,KAAK,CAACe,KAAK,EAAE,CAAC,EAAE,IAAI,CAACxB,UAAU,EAAE,IAAI,CAACI,QAAQ,CAAC;EAClG;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}