{"ast":null,"code":"import Piece from \"../Piece\";\nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class Queen extends Piece {\n  constructor(position, team) {\n    let possibleMoves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(position, team, \"queen\", possibleMoves);\n  }\n  getPossibleMoves(pieces) {\n    const x = this.position.x;\n    const y = this.position.y;\n    let upperRight = true;\n    let upperLeft = true;\n    let bottomRight = true;\n    let bottomLeft = true;\n    // TOP\n    for (let i = 1; i < 8; i++) {\n      if (y + i > 7) break;\n      let passedTile = new Position(x, y + i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // BOTTOM\n    for (let i = 1; i < 8; i++) {\n      if (y - i < 0) break;\n      let passedTile = new Position(x, y - i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // RIGHT\n    for (let i = 1; i < 8; i++) {\n      if (x + i > 7) break;\n      let passedTile = new Position(x + i, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // LEFT\n    for (let i = 1; i < 8; i++) {\n      if (x - i < 0) break;\n      let passedTile = new Position(x - i, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    for (let i = 1; i < 8; i++) {\n      if (x + i > 7 || y + i > 7) upperRight = false;\n      if (x - i < 0 || y + i > 7) upperLeft = false;\n      if (x + i > 7 || y - i < 0) bottomRight = false;\n      if (x - i < 0 || y - i < 0) bottomLeft = false;\n\n      // UPPER RIGHT\n      let passedTile = new Position(x + i, y + i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && upperRight) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && upperRight) {\n        upperRight = false;\n      }\n\n      // UPPER LEFT\n      passedTile = new Position(x - i, y + i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && upperLeft) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && upperLeft) {\n        upperLeft = false;\n      }\n      // BOTTOM RIGHT\n      passedTile = new Position(x + i, y - i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && bottomRight) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && bottomRight) {\n        bottomRight = false;\n      }\n\n      // BOTTOM LEFT\n      passedTile = new Position(x - i, y - i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && bottomLeft) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && bottomLeft) {\n        bottomLeft = false;\n      }\n    }\n    return this.possibleMoves;\n  }\n  clone() {\n    return new Queen(this.position.clone(), this.team, this.possibleMoves.map(move => move.clone()));\n  }\n}","map":{"version":3,"names":["Piece","Position","Movement","movement","Queen","constructor","position","team","possibleMoves","arguments","length","undefined","getPossibleMoves","pieces","x","y","upperRight","upperLeft","bottomRight","bottomLeft","i","passedTile","tileIsEmptyOrCaptured","push","tileIsOccupied","clone","map","move"],"sources":["/Users/lao/Desktop/chess-app/client/src/models/pieces/Queen.js"],"sourcesContent":["import Piece from \"../Piece\";\nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class Queen extends Piece {\n  constructor(position, team, possibleMoves = []) {\n    super(position, team, \"queen\", possibleMoves);\n  }\n  getPossibleMoves(pieces) {\n    const x = this.position.x;\n    const y = this.position.y;\n\n    let upperRight = true;\n    let upperLeft = true;\n    let bottomRight = true;\n    let bottomLeft = true;\n    // TOP\n    for (let i = 1; i < 8; i++) {\n      if (y + i > 7) break;\n      let passedTile = new Position(x, y + i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // BOTTOM\n    for (let i = 1; i < 8; i++) {\n      if (y - i < 0) break;\n      let passedTile = new Position(x, y - i);\n\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // RIGHT\n    for (let i = 1; i < 8; i++) {\n      if (x + i > 7) break;\n      let passedTile = new Position(x + i, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    // LEFT\n    for (let i = 1; i < 8; i++) {\n      if (x - i < 0) break;\n      let passedTile = new Position(x - i, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces)) break;\n    }\n    \n    for (let i = 1; i < 8; i++) {\n      if (x + i > 7 || y + i > 7) upperRight = false;\n      if (x - i < 0 || y + i > 7) upperLeft = false;\n      if (x + i > 7 || y - i < 0) bottomRight = false;\n      if (x - i < 0 || y - i < 0) bottomLeft = false;\n\n      // UPPER RIGHT\n      let passedTile = new Position(x + i, y + i);\n      if (\n        movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) &&\n        upperRight\n      ) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && upperRight) {\n        upperRight = false;\n      }\n\n      // UPPER LEFT\n      passedTile = new Position(x - i, y + i);\n      if (\n        movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) &&\n        upperLeft\n      ) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && upperLeft) {\n        upperLeft = false;\n      }\n      // BOTTOM RIGHT\n      passedTile = new Position(x + i, y - i);\n      if (\n        movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) &&\n        bottomRight\n      ) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && bottomRight) {\n        bottomRight = false;\n      }\n\n      // BOTTOM LEFT\n      passedTile = new Position(x - i, y - i);\n      if (\n        movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) &&\n        bottomLeft\n      ) {\n        this.possibleMoves.push(passedTile);\n      }\n      if (movement.tileIsOccupied(passedTile, pieces) && bottomLeft) {\n        bottomLeft = false;\n      }\n    }\n    return this.possibleMoves;\n  }\n  clone() {\n    return new Queen(\n      this.position.clone(),\n      this.team,\n      this.possibleMoves.map((move) => move.clone()),\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}