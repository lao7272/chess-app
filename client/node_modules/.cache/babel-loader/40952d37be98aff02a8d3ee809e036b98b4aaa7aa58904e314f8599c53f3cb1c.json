{"ast":null,"code":"import Piece from \"../Piece\";\nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class Bishop extends Piece {\n  constructor(position, team) {\n    let possibleMoves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(position, team, \"bishop\", possibleMoves);\n  }\n  getPossibleMoves(pieces) {\n    const x = this.position.x;\n    const y = this.position.y;\n    let upperRight = true;\n    let upperLeft = true;\n    let bottomRight = true;\n    let bottomLeft = true;\n    for (let i = 1; i < 8; i++) {\n      if (x + i > 7 || y + i > 7) upperRight = false;\n      if (x - i < 0 || y + i > 7) upperLeft = false;\n      if (x + i > 7 || y - i < 0) bottomRight = false;\n      if (x - i < 0 || y - i < 0) bottomLeft = false;\n\n      // UPPER RIGHT\n      let passedTile = new Position(x + i, y + i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && upperRight) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces) && upperRight) upperRight = false;\n\n      // UPPER LEFT\n      passedTile = new Position(x - i, y + i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && upperLeft) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces) && upperLeft) upperLeft = false;\n      // BOTTOM RIGHT\n      passedTile = new Position(x + i, y - i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && bottomRight) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces) && bottomRight) bottomRight = false;\n\n      // BOTTOM LEFT\n      passedTile = new Position(x - i, y - i);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && bottomLeft) {\n        this.possibleMoves.push(passedTile);\n      }\n      ;\n      if (movement.tileIsOccupied(passedTile, pieces) && bottomLeft) bottomLeft = false;\n    }\n    return this.possibleMoves;\n  }\n  clone() {\n    return new Bishop(this.position.clone(), this.team, this.possibleMoves.map(move => move.clone()));\n  }\n}\n\n// let upperConstraints = true;\n// let bottomConstraints = true;\n// for (let j = -1; j < 2; j += 2) {\n//     if(x + (i * j) > 7 || y + i > 7) upperConstraints = false;\n//     if(x + (i * j) < 0 || y - i < 0) bottomConstraints = false;\n//     const upperMove = new Position(x + (i * j), y + i);\n//     const bottomMove = new Position(x + (i * j), y - i);\n//     if (movement.tileIsEmptyOrCaptured(upperMove, pieces, this.team) && upperConstraints) {\n//         this.possibleMoves.push(upperMove);\n//     };\n//     if (movement.tileIsOccupied(upperMove, pieces) && upperConstraints) upperConstraints = false;\n\n//     if (movement.tileIsEmptyOrCaptured(bottomMove, pieces, this.team) && bottomConstraints) {\n//         this.possibleMoves.push(bottomMove);\n//     };\n//     if (movement.tileIsOccupied(bottomMove, pieces) && upperConstraints) bottomConstraints = false;\n// }","map":{"version":3,"names":["Piece","Position","Movement","movement","Bishop","constructor","position","team","possibleMoves","arguments","length","undefined","getPossibleMoves","pieces","x","y","upperRight","upperLeft","bottomRight","bottomLeft","i","passedTile","tileIsEmptyOrCaptured","push","tileIsOccupied","clone","map","move"],"sources":["/Users/lao/Desktop/chess-app/src/models/pieces/Bishop.js"],"sourcesContent":["import Piece from \"../Piece\";\nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class Bishop extends Piece {\n    constructor (position, team, possibleMoves = []) {\n        super(position, team, \"bishop\", possibleMoves);\n    }\n    getPossibleMoves (pieces) {\n        const x = this.position.x;\n        const y = this.position.y;\n        let upperRight = true;\n        let upperLeft = true;\n        let bottomRight = true; \n        let bottomLeft = true;\n\n        for (let i = 1; i < 8; i++) {\n            if(x + i > 7 || y + i > 7) upperRight = false;\n            if(x - i < 0 || y + i > 7) upperLeft = false;\n            if(x + i > 7 || y - i < 0) bottomRight = false;\n            if(x - i < 0 || y - i < 0) bottomLeft = false;\n\n            // UPPER RIGHT\n            let passedTile = new Position (x + i, y + i);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && upperRight) {\n                this.possibleMoves.push(passedTile);\n            };\n            if (movement.tileIsOccupied(passedTile, pieces) && upperRight) upperRight = false;\n\n            // UPPER LEFT\n            passedTile = new Position (x - i, y + i);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && upperLeft) {\n                this.possibleMoves.push(passedTile);\n            };\n            if (movement.tileIsOccupied(passedTile, pieces) && upperLeft) upperLeft = false;\n            // BOTTOM RIGHT\n            passedTile = new Position (x + i, y - i);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && bottomRight) {\n                this.possibleMoves.push(passedTile);\n            };\n            if (movement.tileIsOccupied(passedTile, pieces) && bottomRight) bottomRight = false;\n\n            // BOTTOM LEFT\n            passedTile = new Position (x - i, y - i);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team) && bottomLeft) {\n                this.possibleMoves.push(passedTile);\n            };\n            if (movement.tileIsOccupied(passedTile, pieces) && bottomLeft) bottomLeft = false;\n\n        }\n        return this.possibleMoves;\n    }\n    clone(){\n        return new Bishop(this.position.clone(), this.team, this.possibleMoves.map(move => move.clone()));\n    }\n}\n\n// let upperConstraints = true;\n// let bottomConstraints = true;\n// for (let j = -1; j < 2; j += 2) {\n//     if(x + (i * j) > 7 || y + i > 7) upperConstraints = false;\n//     if(x + (i * j) < 0 || y - i < 0) bottomConstraints = false;\n//     const upperMove = new Position(x + (i * j), y + i);\n//     const bottomMove = new Position(x + (i * j), y - i);\n//     if (movement.tileIsEmptyOrCaptured(upperMove, pieces, this.team) && upperConstraints) {\n//         this.possibleMoves.push(upperMove);\n//     };\n//     if (movement.tileIsOccupied(upperMove, pieces) && upperConstraints) upperConstraints = false;\n\n//     if (movement.tileIsEmptyOrCaptured(bottomMove, pieces, this.team) && bottomConstraints) {\n//         this.possibleMoves.push(bottomMove);\n//     };\n//     if (movement.tileIsOccupied(bottomMove, pieces) && upperConstraints) bottomConstraints = false;\n// }   "],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}