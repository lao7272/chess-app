{"ast":null,"code":"import Piece from \"../Piece\";\nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class King extends Piece {\n  constructor(position, team, hasMoved) {\n    let possibleMoves = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    super(position, team, \"king\", possibleMoves);\n    this.hasMoved = hasMoved;\n  }\n  getPossibleMoves(pieces) {\n    const x = this.position.x;\n    const y = this.position.y;\n    let passedTile = new Position(x + 1, y + 1);\n    if (!(x + 1 > 7 || y + 1 > 7)) {\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    if (!(x - 1 < 0 || y + 1 > 7)) {\n      passedTile = new Position(x - 1, y + 1);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    if (!(x + 1 > 7 || y - 1 < 0)) {\n      passedTile = new Position(x + 1, y - 1);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    if (!(x - 1 < 0 || y - 1 < 0)) {\n      passedTile = new Position(x - 1, y - 1);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    if (!(y + 1 > 7)) {\n      passedTile = new Position(x, y + 1);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    if (!(y - 1 < 0)) {\n      passedTile = new Position(x, y - 1);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    if (!(x + 1 > 7)) {\n      passedTile = new Position(x + 1, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    if (!(x - 1 < 0)) {\n      passedTile = new Position(x - 1, y);\n      if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n    }\n    return this.possibleMoves;\n  }\n  castling(pieces) {\n    const possibleMoves = [];\n    if (this.hasMoved) return possibleMoves;\n    const rooks = pieces.filter(p => p.isRook && p.team === this.team && !p.hasMoved);\n    for (const rook of rooks) {\n      const direction = rook.position.x - this.position.x > 0 ? 1 : -1;\n      const adjacentPosition = this.position.clone();\n      adjacentPosition.x += direction;\n      if (!rook.possibleMoves.some(m => m.samePosition(adjacentPosition))) continue;\n      const castlingSquares = rook.possibleMoves.filter(m => m.y === this.position.y);\n      let valid = true;\n      const enemies = pieces.filter(p => p.team !== this.team);\n      for (const enemy of enemies) {\n        if (!enemy.possibleMoves) continue;\n        for (const move of enemy.possibleMoves) {\n          if (castlingSquares.some(s => s.samePosition(move))) valid = false;\n          if (!valid) break;\n        }\n        if (!valid) break;\n      }\n      if (!valid) continue;\n      adjacentPosition.x += direction;\n      possibleMoves.push(adjacentPosition);\n    }\n    return possibleMoves;\n  }\n  clone() {\n    return new King(this.position.clone(), this.team, this.hasMoved, this.possibleMoves.map(move => move.clone()));\n  }\n}","map":{"version":3,"names":["Piece","Position","Movement","movement","King","constructor","position","team","hasMoved","possibleMoves","arguments","length","undefined","getPossibleMoves","pieces","x","y","passedTile","tileIsEmptyOrCaptured","push","castling","rooks","filter","p","isRook","rook","direction","adjacentPosition","clone","some","m","samePosition","castlingSquares","valid","enemies","enemy","move","s","map"],"sources":["/Users/lao/Desktop/chess-app/client/src/models/pieces/King.js"],"sourcesContent":["import Piece from \"../Piece\"; \nimport Position from \"../Positition\";\nimport Movement from \"./Movement\";\nconst movement = new Movement();\nexport default class King extends Piece {\n    constructor (position, team, hasMoved, possibleMoves = []) {\n        super(position, team, \"king\", possibleMoves);\n        this.hasMoved = hasMoved;\n    }\n    getPossibleMoves(pieces) {\n        const x = this.position.x;\n        const y = this.position.y;\n        let passedTile = new Position(x + 1, y + 1);\n        if(!(x + 1 > 7 || y + 1 > 7)) {\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n        if(!(x - 1 < 0 || y + 1 > 7)) {\n            passedTile = new Position(x - 1, y + 1);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n        if(!(x + 1 > 7 || y - 1 < 0)) {\n            passedTile = new Position(x + 1, y - 1)\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n        if(!(x - 1 < 0 || y - 1 < 0)) {\n            passedTile = new Position(x - 1, y - 1)\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n    \n        if(!(y + 1 > 7)) {\n            passedTile = new Position(x, y + 1);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n        if(!(y - 1 < 0)) {\n            passedTile = new Position(x, y - 1);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n        if(!(x + 1 > 7)) {\n            passedTile = new Position(x + 1, y);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n        if(!(x - 1  < 0)) {\n            passedTile = new Position(x - 1, y);\n            if (movement.tileIsEmptyOrCaptured(passedTile, pieces, this.team)) this.possibleMoves.push(passedTile);\n        }\n        return this.possibleMoves;\n    }\n\n    castling(pieces) {\n        const possibleMoves = [];\n        if (this.hasMoved) return possibleMoves;\n        const rooks = pieces.filter(p => p.isRook && p.team === this.team && !p.hasMoved)\n        for (const rook of rooks) {\n            const direction = rook.position.x - this.position.x > 0 ? 1 : -1;\n            const adjacentPosition = this.position.clone();\n            adjacentPosition.x += direction;\n    \n            if(!rook.possibleMoves.some(m => m.samePosition(adjacentPosition))) continue;\n    \n            const castlingSquares = rook.possibleMoves.filter(m => m.y === this.position.y);\n    \n            let valid = true;\n            const enemies = pieces.filter(p => p.team !== this.team);\n            for (const enemy of enemies) {\n                if(!enemy.possibleMoves) continue;\n                for (const move of enemy.possibleMoves){\n                    if(castlingSquares.some(s => s.samePosition(move))) valid = false;\n                    if(!valid) break;\n                }\n                if(!valid) break;\n            }\n            if (!valid) continue;\n            adjacentPosition.x += direction;\n            possibleMoves.push(adjacentPosition);\n        }\n        return possibleMoves;\n    }\n    clone(){\n        return new King(this.position.clone(), this.team, this.hasMoved, this.possibleMoves.map(move => move.clone()));\n    }\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,UAAU;AAC5B,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,QAAQ,MAAM,YAAY;AACjC,MAAMC,QAAQ,GAAG,IAAID,QAAQ,EAAE;AAC/B,eAAe,MAAME,IAAI,SAASJ,KAAK,CAAC;EACpCK,WAAWA,CAAEC,QAAQ,EAAEC,IAAI,EAAEC,QAAQ,EAAsB;IAAA,IAApBC,aAAa,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IACrD,KAAK,CAACJ,QAAQ,EAAEC,IAAI,EAAE,MAAM,EAAEE,aAAa,CAAC;IAC5C,IAAI,CAACD,QAAQ,GAAGA,QAAQ;EAC5B;EACAK,gBAAgBA,CAACC,MAAM,EAAE;IACrB,MAAMC,CAAC,GAAG,IAAI,CAACT,QAAQ,CAACS,CAAC;IACzB,MAAMC,CAAC,GAAG,IAAI,CAACV,QAAQ,CAACU,CAAC;IACzB,IAAIC,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;IAC3C,IAAG,EAAED,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAC1B,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IACA,IAAG,EAAEF,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAC1BC,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;MACvC,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IACA,IAAG,EAAEF,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAC1BC,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;MACvC,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IACA,IAAG,EAAEF,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAC1BC,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;MACvC,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IAEA,IAAG,EAAED,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MACbC,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;MACnC,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IACA,IAAG,EAAED,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MACbC,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;MACnC,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IACA,IAAG,EAAEF,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MACbE,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,GAAG,CAAC,EAAEC,CAAC,CAAC;MACnC,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IACA,IAAG,EAAEF,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC,EAAE;MACdE,UAAU,GAAG,IAAIhB,QAAQ,CAACc,CAAC,GAAG,CAAC,EAAEC,CAAC,CAAC;MACnC,IAAIb,QAAQ,CAACe,qBAAqB,CAACD,UAAU,EAAEH,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACE,aAAa,CAACU,IAAI,CAACF,UAAU,CAAC;IAC1G;IACA,OAAO,IAAI,CAACR,aAAa;EAC7B;EAEAW,QAAQA,CAACN,MAAM,EAAE;IACb,MAAML,aAAa,GAAG,EAAE;IACxB,IAAI,IAAI,CAACD,QAAQ,EAAE,OAAOC,aAAa;IACvC,MAAMY,KAAK,GAAGP,MAAM,CAACQ,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,IAAID,CAAC,CAAChB,IAAI,KAAK,IAAI,CAACA,IAAI,IAAI,CAACgB,CAAC,CAACf,QAAQ,CAAC;IACjF,KAAK,MAAMiB,IAAI,IAAIJ,KAAK,EAAE;MACtB,MAAMK,SAAS,GAAGD,IAAI,CAACnB,QAAQ,CAACS,CAAC,GAAG,IAAI,CAACT,QAAQ,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MAChE,MAAMY,gBAAgB,GAAG,IAAI,CAACrB,QAAQ,CAACsB,KAAK,EAAE;MAC9CD,gBAAgB,CAACZ,CAAC,IAAIW,SAAS;MAE/B,IAAG,CAACD,IAAI,CAAChB,aAAa,CAACoB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,YAAY,CAACJ,gBAAgB,CAAC,CAAC,EAAE;MAEpE,MAAMK,eAAe,GAAGP,IAAI,CAAChB,aAAa,CAACa,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACd,CAAC,KAAK,IAAI,CAACV,QAAQ,CAACU,CAAC,CAAC;MAE/E,IAAIiB,KAAK,GAAG,IAAI;MAChB,MAAMC,OAAO,GAAGpB,MAAM,CAACQ,MAAM,CAACC,CAAC,IAAIA,CAAC,CAAChB,IAAI,KAAK,IAAI,CAACA,IAAI,CAAC;MACxD,KAAK,MAAM4B,KAAK,IAAID,OAAO,EAAE;QACzB,IAAG,CAACC,KAAK,CAAC1B,aAAa,EAAE;QACzB,KAAK,MAAM2B,IAAI,IAAID,KAAK,CAAC1B,aAAa,EAAC;UACnC,IAAGuB,eAAe,CAACH,IAAI,CAACQ,CAAC,IAAIA,CAAC,CAACN,YAAY,CAACK,IAAI,CAAC,CAAC,EAAEH,KAAK,GAAG,KAAK;UACjE,IAAG,CAACA,KAAK,EAAE;QACf;QACA,IAAG,CAACA,KAAK,EAAE;MACf;MACA,IAAI,CAACA,KAAK,EAAE;MACZN,gBAAgB,CAACZ,CAAC,IAAIW,SAAS;MAC/BjB,aAAa,CAACU,IAAI,CAACQ,gBAAgB,CAAC;IACxC;IACA,OAAOlB,aAAa;EACxB;EACAmB,KAAKA,CAAA,EAAE;IACH,OAAO,IAAIxB,IAAI,CAAC,IAAI,CAACE,QAAQ,CAACsB,KAAK,EAAE,EAAE,IAAI,CAACrB,IAAI,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,aAAa,CAAC6B,GAAG,CAACF,IAAI,IAAIA,IAAI,CAACR,KAAK,EAAE,CAAC,CAAC;EAClH;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}